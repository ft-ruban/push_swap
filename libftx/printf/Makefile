# ğŸ—ï¸ Variables de fichiers
SRC = ft_printf.c ft_printf_cases.c ft_printfd.c ft_printfd_cases.c
OBJ = $(SRC:.c=.o)

# ğŸ“Œ Chemin vers libft
LIBFT_PATH = ../
LIBFT = $(LIBFT_PATH)/libftx.a

# âš™ï¸ Compiler + flags
CC = cc
CFLAGS = -Wall -Wextra -Werror

# ğŸ“¦ Nom de la bibliothÃ¨que finale
NAME = printf.a

# ğŸ¯ RÃ¨gle par dÃ©faut : construire la lib
all: $(NAME)

# ğŸ›ï¸ CrÃ©ation de la bibliothÃ¨que statique
$(NAME): $(OBJ) $(LIBFT)
	ar rcs $(NAME) $(OBJ) $(LIBFT)

# ğŸ“Œ Compilation des fichiers `.c` en `.o`
%.o: %.c ft_printf.h
	$(CC) $(CFLAGS) -c $< -o $@

# ğŸ§ª ExÃ©cutable de test
TEST_EXEC = test_printf
$(TEST_EXEC): $(OBJ) main.c $(LIBFT)
	$(CC) $(CFLAGS) main.c $(OBJ) $(LIBFT) -o $(TEST_EXEC)

# ğŸ§¹ Nettoyage des fichiers objets
clean:
	rm -f $(OBJ)

# ğŸ§¼ Nettoyage total
fclean: clean
	rm -f $(NAME) $(TEST_EXEC) $(OBJ)

# ğŸ”„ Rebuild propre
re: fclean all

debug :
								@echo "Current directory: $(PWD)"
								@echo "Checking libft files:"
								@ls -l $(DIR_LIBFT)

# âš ï¸ S'assurer que `libft` est bien construite avant `printf.a`
$(LIBFT):
	$(MAKE) -C $(LIBFT_PATH) all

.PHONY: all clean fclean re
